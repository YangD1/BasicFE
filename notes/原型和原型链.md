# 原型和原型链
## [class](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes)
- class 是 ES6 语法规范，由 ECMA 委员会发布
- ECMA 只规定语法规则，即我们代码的书写规范，不规定如何实现
- 以上实现方式都是 V8 引擎的实现方式，也是主流的  
JavaScript 类实质上是 JavaScript 现有的基于原型的继承的语法糖（依然是对象）。  
包含的内容：
- constructor
- 属性
- 方法
```javascript
class Student {
  constructor (name, number) {
    this.name = name
    this.number = number
  }
  sayHi() {
    console.log(
      `姓名 ${this.name}，学号 ${this.number}`
    )
  }
}

// 通过类生成实例（对象）
const jack = new Student('Jack', 100)
console.log(jack.name)
console.log(jack.number)
jack.sayHi()

// ... 依据上面可以生成任意多的实例
```

## 继承
- extends
- super
- 扩展或重写方法
```javascript
// 父类
class People {
  constructor(name) {
    this.name = name
  }
  eat() {
    console.log(`${this.name} eat something`)
  }
}

// 子类
class Student extends People {
  constructor(name, number) {
    super(name) // super 用于向父类传递值，如果这个值在父类有处理的话，就能很好的实现代码复用
    this.number = number
  }

  sayHi() {
    console.log(`姓名：${this.name} 学号 ${this.number}`)
  }
}
```

## 类型判断 instanceof
![](images/2020-04-16-15-39-58.png)
代码可以参考上面的内容，`xialuo`这个实例是 `Student` 类的实例，`Student` 继承了 `People` 类，`People` 是 `Objcet` 的子类。  
使用 `instanceof` 只要左边的对象是继承自右边（不一定是第一级继承），便返回 `true`。

## 原型
**注意**：class 实际上是函数（语法糖）  
比如上面父类和子类：  
```javascript
typeof People // 'funciton'
typeof Student // 'funciton'
```
隐式原型和显示原型  
`xialuo`实例的隐式原型： `xialuo.__proto__`  
`Student`类的显原型： `Student.prototype`  
`xialuo.__proto__ === Student.prototype`  
![](images/2020-04-16-15-57-32.png)

### 原型关系
- 每个 **class** 都有显示原型 `prototype`
- 每个**实例**都有隐式原型`__proto__`
- 实例的 `__proto__`指向对应 class 的 prototype  
### 基于原型的执行规则
- 获取属性 `xialuo.name` 或执行方法 `xialuo.sayHi()` 时
- 显在自身属性和方法寻找
- 如果找不到则自动去 `__proto__`中寻找

## 原型链
![](images/2020-04-16-16-06-15.png)  
> 判断一个属性是否是实例自己的属性（是否有指定的键）可以用 Object.prototype.hasOwnProperty()  
![](images/2020-04-16-16-24-19.png)  
每个对象都是继承于 Objcet，也就是说每个对象原型链的终点都是 Object，因为 Objcet 的显示原型的隐式原型指向的是 null。